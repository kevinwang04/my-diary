


#### 之前一直使用React，也听说了其高效的整页渲染是基于出色的dom-diff算法，有兴趣去了解了一下。

----

##### 首先，什么是dom diff

> Web界面由DOM树来构成，当其中某一部分发生变化时，其实就是对应的某个DOM节点发生了变化。在React中，构建UI界面的思路是由当前状态决定界面。前后两个状态就对应两套界面，然后由React来比较两个界面的区别，这就需要对DOM树进行Diff算法分析。

简单来说，就是找出变化前的dom树和变化后的dom树的差别，并且完成从前到后渲染的转换过程。原先的diff算法复杂度要O(n^3)，react 基于两点假设让这种复杂度降到一次方O(n)，这一点是相对牛x的，以下是两个我也看不太懂的假设：

1. 两个相同组件产生类似的DOM结构，不同的组件产生不同的DOM结构

2. 对于同一层次的一组子节点，它们可以通过唯一的id进行区分

那么react是如何比较两个节点的呢？

分两步，第一种情如果况节点类型不同 ，react会直接在树中删除前面的节点，然后插入新节点。

> 当React在同一个位置遇到不同的组件时，也是简单的销毁第一个组件，而把新创建的组件加上去。这正是应用了第一个假设，不同的组件一般会产生不一样的DOM结构，与其浪费时间去比较它们基本上不会等价的DOM结构，还不如完全创建一个新的组件加上去。

![两次dom树比较](http://cdn1.infoqstatic.com/statics_s2_20160726-0420u1/resource/articles/react-dom-diff/zh/resources/0909000.png)

React只会对相同颜色方框内的DOM节点进行比较，即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个DOM树的比较。

![enter image description here](http://cdn1.infoqstatic.com/statics_s2_20160726-0420u1/resource/articles/react-dom-diff/zh/resources/0909001.png)

以上的DOM节点中A节点被整个移动到D节点下，直观的考虑DOM Diff操作应该是：

	A.parent.remove(A); 
	D.append(A);

但因为React只会简单的考虑同层节点的位置变换，对于不同层的节点，只有简单的创建和删除。当根节点发现子节点中A不见了，就会直接销毁A；而当D发现自己多了一个子节点A，则会创建一个新的A作为子节点。因此对于这种结构的转变的实际操作是：

	A.destroy();
	A = new A();
	A.append(new B());
	A.append(new C());
	D.append(A);

可以看到，以A为根节点的树被整个重新创建。
虽然看上去这样的算法有些“简陋”，但是其基于的是第一个假设：两个不同组件一般产生不一样的DOM结构。根据React官方博客，这一假设至今为止没有导致严重的性能问题。这当然也给我们一个提示，在实现自己的组件时，保持稳定的DOM结构会有助于性能的提升。例如，我们有时可以通过CSS隐藏或显示某些节点，而不是真的移除或添加DOM节点。

refer to: 

[DOM diff](http://www.infoq.com/cn/articles/react-dom-diff)